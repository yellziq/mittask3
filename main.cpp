#include <iostream>
#include <climits>

using namespace std; // Подключаем пространство имен std, чтобы не использовать std:: перед стандартными функциями

struct list { // Структура узла списка
    int inf;     // Значение узла
    list* next;  // Указатель на следующий узел
    list* prev;  // Указатель на предыдущий узел
};

void push(list*& h, list*& t, int x) { // Функция добавления элемента в конец списка
    list* r = new list;        // Создаем новый узел
    r->inf = x;               // Задаем значение узла
    r->next = nullptr;        // Устанавливаем указатель на следующий узел в nullptr
    if (!h && !t) {           // Если список пуст
        r->prev = nullptr;     // Устанавливаем указатель на предыдущий узел в nullptr
        h = r;                 // Начало списка указывает на новый узел
    }
    else {                    // Иначе
        t->next = r;           // Конец списка указывает на новый узел
        r->prev = t;           // Новый узел указывает на конец списка
    }
    t = r; // Конец списка указывает на новый узел
}

void del_node(list*& h, list*& t, list* r) { // Функция удаления узла
    if (r == h && r == t) { // Если узел является единственным в списке
        h = t = nullptr;   // Очищаем список
    }
    else if (r == h) {      // Если узел является началом списка
        h = h->next;       // Начало списка указывает на следующий узел
        h->prev = nullptr; // Предыдущий узел нового начала списка становится nullptr
    }
    else if (r == t) {      // Если узел является концом списка
        t = t->prev;       // Конец списка указывает на предыдущий узел
        t->next = nullptr; // Следующий узел нового конца списка становится nullptr
    }
    else {                  // Если узел находится в середине списка
        r->next->prev = r->prev; // Следующий узел указывает на предыдущий удаляемого узла
        r->prev->next = r->next; // Предыдущий узел указывает на следующий удаляемого узла
    }

    delete r; // Удаляем узел
}

void remove_non_max(list*& h) { // Функция удаления элементов, которые меньше среднего арифметического последующих за ними элементов
    list* curr = h;           // Текущий узел списка
    list* t = h;             // Конец списка

    while (curr) {           // Перебираем список
        int sum = 0;        // Сумма значений последующих элементов
        int count = 0;     // Количество последующих элементов

        // Вычисляем сумму и количество последующих элементов
        list* r = curr->next; // Текущий узел в итерации по последующим элементам
        while (r) {          // Пока есть последующие элементы
            sum += r->inf;   // Прибавляем значение текущего элемента к сумме
            count++;        // Увеличиваем количество последующих элементов
            r = r->next;    // Переходим к следующему элементу
        }

        // Проверяем условие и удаляем элемент, если он не максимальный
        if (count > 0 && curr->inf < sum / count) { // Если количество элементов больше 0 и значение текущего элемента меньше среднего
            list* temp = curr;                 // Сохраняем текущий узел
            curr = curr->next;              // Переходим к следующему элементу
            del_node(h, t, temp);           // Удаляем текущий узел
        }
        else {                 // Если условие не выполнено
            curr = curr->next; // Переходим к следующему элементу
        }
    }
}

void print(list* h) { // Функция печати списка
    list* p = h;       // Текущий узел списка
    while (p) {        // Пока есть элементы в списке
        cout << p->inf << " "; // Выводим значение узла
        p = p->next;        // Переходим к следующему узлу
    }
    cout << endl; // Выводим перевод строки
}

int main() {
    list* head = nullptr; // Начало списка
    list* tail = nullptr; // Конец списка

    int n; // Количество элементов в списке
    cout << "Введите количество элементов списка: ";
    cin >> n;

    for (int i = 0; i < n; i++) { // Для каждого элемента
        int x; // Значение элемента
        cout << "Введите элемент №"


            << i + 1 << ": ";
        cin >> x;
        push(head, tail, x); // Добавляем элемент в конец списка
    }

    cout << "Исходный список: ";
    print(head); // Выводим исходный список

    remove_non_max(head); // Удаляем элементы, которые меньше среднего арифметического последующих за ними элементов

    cout << "Список после удаления лишних элементов: ";
    print(head); // Выводим список после удаления

    return 0; // Возвращаем 0 из главной функции
}
