
// Подключаем стандартные библиотеки ввода/вывода и математических функций
#include <iostream>
#include <cmath>
#include <queue>

// Используем пространство имен std для удобства
using namespace std;

// Структура дерева
struct tree {
    // Поле данных
    int inf;

    // Указатели на левое и правое поддеревья
    tree* right;
    tree* left;
};

// Функция создания узла дерева
tree* node(int x) {
    // Выделяем память для нового узла
    tree* n = new tree;

    // Заполняем поля узла
    n->inf = x;
    n->left = n->right = NULL;

    // Возвращаем указатель на новый узел
    return n;
}

// Функция создания дерева
void create(tree*& tr, int n) {
    int x;
    if (n > 0) {
        cin >> x;
        tr = node(x);
        int nl = n / 2;
        int nr = n - nl - 1;
        create(tr->left, nl);
        create(tr->right, nr);
    }
}

// Функция прямого обхода дерева
void preorder(tree* tr) {

    if (tr) {
        // Выводим данные текущего узла
        cout << tr->inf;

        // Рекурсивно обходим левое поддерево
        preorder(tr->left);

        // Рекурсивно обходим правое поддерево
        preorder(tr->right);
    }
}

// Функция определения высоты левого поддерева
int lefth(tree* tr) {
    int k = 0;
    tree* x = tr;
    while (x) {
        k++;
        x = x->left;
    }
    return k - 1;
}

// Функция определения высоты правого поддерева
int righth(tree* tr) {
    int k = 0;
    tree* x = tr;
    while (x) {
        k++;
        x = x->right;
    }
    return k - 1;
}

// Функция добавления узла в дерево
void add(tree*& tr, int x) {
    // Создаем новый узел со значением x
    tree* n = node(x);

    // Указатель на текущий узел дерева
    tree* y = tr;

    // Если высоты левого и правого поддеревьев равны, то добавляем новый узел в левое поддерево
    if (lefth(tr) == righth(tr)) {
        // Ищем самое левое поддерево
        do {
            y = y->left;
        } while (y->left);

        // Если левое поддерево пусто, то добавляем новый узел слева
        if (!y->left) y->left = n;
        // Иначе добавляем новый узел справа
        else y->right = n;
    }
    // Иначе добавляем новый узел в правое поддерево
    else {
        // Ищем самое правое поддерево
        do {
            y = y->right;
        } while (y->right);

        // Если правое поддерево пусто, то добавляем новый узел слева
        if (!y->left) y->left = n;
        // Иначе добавляем новый узел справа
        else y->right = n;
    }
}

// Функция поиска узла в дереве
void find(tree* tr, int x, tree*& res) {
    if (tr) {
        if (tr->inf == x) {
            res = tr;
        }
        else {
            find(tr->left, x, res);
            find(tr->right, x, res);
        }
    }
}

// Функция удаления узла из дерева
void del_n(tree* tr, int val) {
    // Ищем узел, который нужно удалить
    tree* y;
    find(tr, val, y);

    // Если узел найден, то удаляем его
    if (y) {
        // Если левое поддерево пусто, то удаляем узел
        if (lefth(tr) == 0) tr = NULL;
        // Иначе, если высоты левого и правого поддеревьев не равны, то удаляем узел из левого поддерева
        else if (lefth(tr) != righth(tr)) {
            // Ищем узел с максимальным значением в левом поддереве
            tree* x = tr->left;
            do {
                x = x->left;
            } while (x->left->left);

            // Если у узла с максимальным значением есть правое поддерево, то переносим значение узла с максимальным значением в удаляемый узел
            if (x->right) {
                if (x->right->inf == val) {
                    x->right = NULL;
                }
                else {
                    y->inf = x->right->inf;
                    x->right = NULL;
                }
                delete x->right;
            }
            // Иначе переносим значение левого поддерева узла с максимальным значением в удаляемый узел
            else {
                if (x->left->inf == val) {
                    x->left = NULL;
                }
                else {
                    y->inf = x->left->inf;
                    x->left = NULL;
                }
                delete x->left;
            }
        }
        // Иначе удаляем узел из правого поддерева
        else {
            // Ищем узел с максимальным значением в правом поддереве
            tree* x = tr->right;
            do {
                x = x->right;
            } while (x->right->right);

            // Если у узла с максимальным значением есть правое поддерево, то переносим значение узла с максимальным значением в удаляемый узел
            if (x->right) {
                if (x->right->inf == val) {
                    x->right = NULL;
                }
                else {
                    y->inf = x->right->inf;
                    x->right = NULL;
                }
                delete x->right;
            }
            // Иначе переносим значение левого поддерева узла с максимальным значением в удаляемый узел
            else {
                if (x->left->inf == val) {
                    x->left = NULL;
                }
                else {
                    y->inf = x->left->inf;
                    x->left = NULL;
                }
                delete x->left;
            }
        }
    }
}
// Функция печати дерева по уровням
void print(tree* tr, int k) {
    if (!tr) cout << "Empty tree\n"; // Если дерево пустое, выводим "Empty tree"
    else {
        queue<tree*> cur, next; // Очереди для хранения узлов текущего и следующего уровней
        tree* r = tr; // Корень дерева
        cur.push(r); // Добавляем корень в очередь текущего уровня
        int j = 0; // Счетчик узлов на текущем уровне
        while (cur.size()) { // Пока очередь текущего уровня не пуста
            if (j == 0) { // Если это первый узел на уровне
                for (int i = 0; i < (int)pow(2.0, k) - 1; i++) // Выводим пробелы для выравнивания
                    cout << ' ';
            }
            tree* buf = cur.front(); // Извлекаем узел из очереди текущего уровня
            cur.pop(); // Удаляем узел из очереди текущего уровня
            j++; // Увеличиваем счетчик узлов на текущем уровне
            if (buf) { // Если узел не пустой
                cout << buf->inf; // Выводим значение узла
                next.push(buf->left); // Добавляем левый потомок узла в очередь следующего уровня
                next.push(buf->right); // Добавляем правый потомок узла в очередь следующего уровня
            }
            if (!buf) { // Если узел пустой
                cout << ' '; // Выводим пробел
            }
            if (cur.empty()) { // Если очередь текущего уровня пуста
                cout << endl; // Выводим перевод строки
                swap(cur, next); // Меняем очереди текущего и следующего уровней
                j = 0; // Сбрасываем счетчик узлов на текущем уровне
                k--; // Уменьшаем высоту дерева на 1
            }
        }
    }
}

int main() {
    int n;
    cout << "Введите количество узлов дерева: ";
    cin >> n;
    tree* root = NULL;
    create(root, n);
    cout << "Дерево в прямом порядке: ";
    preorder(root);
    cout << endl;

    print(root, int(log((float)n) / log((float)2.0))); // Печатаем дерево по уровням
    cout << endl;
    return 0;
}