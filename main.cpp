
#include <iostream> // Подключаем стандартный поток ввода-вывода
#include <climits>  // Подключаем библиотеку для работы с константами целочисленных типов

using namespace std; // Используем пространство имен std

struct list { // Определяем структуру узла списка
    int inf;    // Значение узла
    list* next; // Указатель на следующий узел
    list* prev; // Указатель на предыдущий узел
};

void push(list*& h, list*& t, int x) { // Функция добавления элемента в конец списка
    list* r = new list; // Создаем новый узел
    r->inf = x;         // Задаем значение узла
    r->next = nullptr;  // Устанавливаем указатель на следующий узел в nullptr
    if (!h && !t) {    // Если список пуст
        r->prev = nullptr; // Устанавливаем указатель на предыдущий узел в nullptr
        h = r;             // Начало списка указывает на новый узел
    }
    else {              // Иначе
        t->next = r;       // Конец списка указывает на новый узел
        r->prev = t;       // Новый узел указывает на конец списка
    }
    t = r; // Конец списка указывает на новый узел
}

void insert_min_before_last(list*& h, list*& t) { // Функция вставки минимального элемента перед последним
    if (!h || !t) // Если список пуст или состоит из одного элемента
        return;  // Возвращаемся

    int last_num = t->inf; // Последнее значение в списке
    list* p = h;           // Указатель на начало списка
    list* min_node = nullptr; // Указатель на минимальный узел
    int min_val = INT_MAX; // Минимальное значение

    while (p) { // Перебираем список
        if (p->inf < min_val && p != t) { // Если значение узла меньше минимального и не равно последнему
            min_val = p->inf;        // Минимальное значение равно значению узла
            min_node = p;            // Минимальный узел равен узлу
        }
        p = p->next; // Переходим к следующему узлу
    }

    if (min_node == nullptr) // Если минимальный узел не найден
        return;              // Возвращаемся

    p = h; // Указатель на начало списка
    while (p) { // Перебираем список
        if (p->inf == last_num) { // Если значение узла равно последнему
            list* new_node = new list; // Создаем новый узел
            new_node->inf = min_val;  // Задаем значение узла
            new_node->next = p;       // Новый узел указывает на текущий узел
            new_node->prev = p->prev; // Новый узел указывает на предыдущий от текущего узла
            if (p == h) {            // Если текущий узел - начало списка
                h = new_node;      // Начало списка указывает на новый узел
            }
            else {                  // Иначе
                p->prev->next = new_node; // Предыдущий узел указывает на новый узел
            }
            p->prev = new_node; // Текущий узел указывает на новый узел
        }
        p = p->next; // Переходим к следующему узлу
    }
}

void print(list* h) { // Функция печати списка
    list* p = h; // Указатель на начало списка
    while (p) {   // Перебираем список
        cout << p->inf << " "; // Выводим значение узла
        p = p->next;         // Переходим к следующему узлу
    }
    cout << std::endl; // Выводим перевод строки
}

int main() { // Главная функция
    list* head = nullptr; // Указатель на начало списка
    list* tail = nullptr; // Указатель на конец списка

    int n; // Количество элементов в списке
    cout << "Введите количество элементов списка: "; // Запрашиваем количество элементов
    cin >> n;                                      // Считываем количество элементов

    for (int i = 0; i < n; i++) { // Для каждого элемента
        int x; // Значение элемента
        cout << "Введите элемент №" << i + 1 << ": "; // Запрашиваем значение элемента
        cin >> x;                                   // Считываем значение элемента
        push(head, tail, x);                       // Добавляем элемент в конец списка
    }

    insert_min_before_last(head, tail); // Вставляем минимальный элемент перед последним
    print(head);                      // Выводим список

    return 0; // Возвращаем