#include <iostream> // Подключение библиотеки для ввода/вывода
using namespace std; // Использование стандартного пространства имен

struct tree {
    int inf; // Значение узла
    tree* left; // Указатель на левого потомка
    tree* right; // Указатель на правого потомка
    tree* parent; // Указатель на родителя
};

tree* node(int x) { // Функция для создания нового узла с заданным значением
    tree* n = new tree; // Выделение памяти под новый узел
    n->inf = x; // Присвоение значения новому узлу
    n->left = nullptr; // Инициализация указателя на левого потомка как nullptr
    n->right = nullptr; // Инициализация указателя на правого потомка как nullptr
    n->parent = nullptr; // Инициализация указателя на родителя как nullptr
    return n; // Возвращение указателя на новый узел
}

void insert(tree*& tr, int x) { // Функция для вставки элемента в бинарное дерево
    if (x % 2 != 0) { // Проверка на четность элемента
        cout << "Нечетный элемент " << x << " не будет вставлен в дерево." << endl; // Вывод сообщения о пропуске нечетного элемента
        return; // Прерывание функции для нечетного элемента
    }

    tree* n = node(x); // Создание нового узла с заданным значением
    if (!tr) tr = n; // Если дерево пустое, то новый узел становится корнем
    else {
        tree* y = tr; // Указатель для перемещения по дереву начинается с корня
        while (y) { // Пока не достигнут конец дерева
            if (n->inf > y->inf) { // Если значение нового узла больше текущего узла
                if (y->right)
                    y = y->right; // Переход к правому потомку
                else {
                    n->parent = y;
                    y->right = n; // Вставка нового узла в правого потомка
                    break;
                }
            }
            else if (n->inf < y->inf) { // Если значение нового узла меньше текущего узла
                if (y->left)
                    y = y->left; // Переход к левому потомку
                else {
                    n->parent = y;
                    y->left = n; // Вставка нового узла в левого потомка
                    break;
                }
            }
        }
    }
}

void inorder(tree* root) { // Функция для обхода дерева в порядке inorder (левый, корень, правый)
    if (root) {
        inorder(root->left); // Рекурсивный вызов для левого поддерева
        cout << root->inf << " "; // Вывод значения текущего узла
        inorder(root->right); // Рекурсивный вызов для правого поддерева
    }
}

int main() {
    setlocale(LC_ALL, "RU");
    int n, x;
    cout << "Введите количество элементов: "; // Запрос пользователю на ввод количества элементов
    cin >> n; // Чтение количества элементов

    tree* tr = nullptr; // Инициализация корня дерева как nullptr

    for (int i = 0; i < n; i++) { // Цикл для ввода элементов и вставки их в дерево
        cout << i + 1 << ": "; // Вывод номера элемента для ввода
        cin >> x; // Чтение значения элемента
        insert(tr, x); // Вставка элемента в дерево
    }

    cout << "Бинарное дерево поиска с четными элементами:" << endl; // Вывод сообщения о выводе дерева
    inorder(tr); // Обход дерева и вывод элементов

    return 0;
}
